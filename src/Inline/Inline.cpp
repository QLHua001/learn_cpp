#include "Inline.h"
#include <iostream>

//! inline函数 总结
/*

## 函数调用是有时间和空间开销的。
程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，
然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。

为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。
这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。

## 当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。

## 和宏一样，内联函数可以定义在头文件中（不用加 static 关键字），并且头文件被多次#include后也不会引发重复定义错误。
这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次#include后会引发重复定义错误。
内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。
这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏。


## 综合本节和上节的内容，可以看到内联函数主要有两个作用，
一是消除函数调用时的开销，二是取代带参数的宏。不过我更倾向于后者，取代带参数的宏更能凸显内联函数存在的意义。
*/
//! inline函数 总结

//! 宏函数 宏展开仅仅是字符串的替换，不会进行任何计算或传值，非常注意括号的使用，否则有未知结果发生
#define SQ(n) ((n)*(n))

//! 推荐使用内联函数来替换带参数的宏。
static inline int square(int n){
    return n*n;
}

void Inline::Inline_Test(){
    int n = 9;
    int val1 = SQ(n+1);
    std::cout << "val1: " << val1 << std::endl;

    int val2 = square(n+2);
    std::cout << "val2: " << val2 << std::endl;
}
